class Counter0 {
  var x: int;
  
  method init() 
    requires acc(x); 
    ensures acc(x) && x == 0;
  {
    x := 0;  
  }

  method inc()
    requires acc(x);
    ensures acc(x) && x == old(x) + 1;
  {
    x := x + 1;
  } 

  method dec()
    requires acc(x);
    ensures acc(x) && x == old(x) - 1;
  {    
    x := x - 1;  
  }

  /** Interesting issues */  

  /* We can expose representation here */
  method magic1() returns (c: Cell) 
    requires acc(x)
    ensures acc(c.n) && x == old(x);
  {
    var c [acc(c.n)];
  }

  /* This should prevent us from exposing representation */
  method magic2() returns (c: Cell)
    requires acc(x);
    ensures acc(x) && x == old(x) && acc(c.n);
  {
    var c [acc(c.n)];
  }
}

class Counter1 refines Counter0 {
  var y: int;
  var z: int;  
  replaces x by acc(y) && acc(z) && x == y - z && y >= 0 && z >= 0;
  
  transforms init() 
  {
    replaces * by {this.y := 0; this.z := 0;}
  }

  transforms inc()
  {    
    replaces * by {this.y := this.y + 1;}
  }

  transforms dec() 
  {
    replaces * by {this.z := this.z + 1;}
  }       

  /** This violates abstraction of x -- we must hold all permissions to x to update it */
  method magic3() 
    requires acc(y);    
  {
    y := y + 1;
  }

  /** This does also -- but it also prohibits us from reading part of the state across refinement */
  method magic4() returns (i)
    requires acc(y);
  {
    i := y;
  }
}

class Cell {var n: int}
/*
class Counter2 refines Counter1 {
  var a: Cell;
  var b: Cell;
  replaces y, z by acc(a) && acc(b) && acc(a.n) && acc(b.n) && y == a.n && z == b.n;
  
  transforms init() 
  {
    replaces * by {
      this.a := new Cell {n := 0};
      this.b := new Cell {n := 0};
    }
  }

  transforms inc() 
  {
    replaces * by {this.a.n := this.a.n + 1;}
  }

  transforms dec()
  {
    replaces * by {this.b.n := this.b.n + 1;}
  }

  transforms magic1() returns (c: Cell)
  {
    replaces * by {c := this.a;}
  }

  transforms magic2() returns (c: Cell)
  {
    replaces * by {c := this.a;}
  }

  transforms magic3()
  {
    replaces * by {this.a.n := this.a.n + 1;}
  }

  transforms magic4() returns (i)
  {
    replaces * by {i := this.a.n;}
  }
}
*/
  
