class Counter0 {
  var x: int;
  
  method init() 
    requires acc(x); 
    ensures acc(x) && x == 0;
  {
    x := 0;  
  }

  method inc()
    requires acc(x);
    ensures acc(x) && x == old(x) + 1;
  {
    x := x + 1;
  } 

  method dec()
    requires acc(x);
    ensures acc(x) && x == old(x) - 1;
  {    
    x := x - 1;  
  }
}

class Counter1 refines Counter0 {
  var y: int;
  var z: int;  
  replaces x by acc(y) && acc(z) && x == y - z && y >= 0 && z >= 0;
  
  refines init() 
  {
    this.y := 0; 
    this.z := 0;
  }

  refines inc()
  {    
    this.y := this.y + 1;
  }

  refines dec() 
  {
    this.z := this.z + 1;
  }       
}

class Cell {var n: int}

/** TODO: 
Two-step data refinement doesn't work for the following reason:
the spec of Counter1 uses the abstract field x which disappears at the concrete method body level.
I'm not sure what a good solution to this problem...
*/

class Counter2 refines Counter1 {
  var a: Cell;
  var b: Cell;
  replaces y, z by acc(a) && acc(b) && acc(a.n) && acc(b.n) && y == a.n && z == b.n;
  
  refines init() 
  {    
    this.a := new Cell {n := 0};
    this.b := new Cell {n := 0};    
  }

  refines inc() 
  {
    this.a.n := this.a.n + 1;
  }

  refines dec()
  {
    this.b.n := this.b.n + 1;
  }
}
  
